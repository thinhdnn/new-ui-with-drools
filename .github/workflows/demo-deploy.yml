name: Live Demo with Ngrok

on:
  workflow_dispatch:
    inputs:
      demo_duration:
        description: 'Demo duration in minutes'
        required: false
        default: '10'
        type: string
      demo_message:
        description: 'Demo description/message'
        required: false
        default: 'Drools UI Demo'
        type: string

# Grant permissions for the workflow to create issues
permissions:
  issues: write
  contents: read

env:
  NODE_VERSION: '22'
  JAVA_VERSION: '21'

jobs:
  live-demo:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Max 15 minutes to prevent infinite runs
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: rule_engine
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    # Install ngrok and nginx
    - name: Install ngrok and nginx
      run: |
        # Install ngrok
        curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
        echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
        sudo apt update && sudo apt install ngrok nginx -y
        ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}

    # Build and start backend
    - name: Build Backend
      working-directory: ./backend
      run: |
        chmod +x ./gradlew
        ./gradlew clean bootJar -x test
        
        # List generated JAR files for debugging
        echo "üìÅ Generated JAR files:"
        ls -la build/libs/
        
        # Find the executable JAR (should be the only one now)
        EXECUTABLE_JAR=$(ls build/libs/*.jar 2>/dev/null | grep -v plain | head -1)
        if [ -f "$EXECUTABLE_JAR" ]; then
          echo "‚úÖ Executable JAR found: $EXECUTABLE_JAR"
          echo "üìä JAR file size: $(du -h "$EXECUTABLE_JAR")"
          # Check if it has Main-Class in manifest
          unzip -q -c "$EXECUTABLE_JAR" META-INF/MANIFEST.MF | grep -q "Main-Class" && echo "‚úÖ Main-Class found in manifest" || echo "‚ùå No Main-Class in manifest"
        else
          echo "‚ùå No executable JAR file found in build/libs/"
          echo "Available files:"
          ls -la build/libs/ || echo "No files in build/libs/"
          exit 1
        fi

    - name: Start Backend in Background
      working-directory: ./backend
      env:
        SPRING_PROFILES_ACTIVE: docker
        SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/rule_engine
        SPRING_DATASOURCE_USERNAME: postgres
        SPRING_DATASOURCE_PASSWORD: postgres
        SPRING_JPA_HIBERNATE_DDL_AUTO: update
        SERVER_PORT: 8080
      run: |
        # Find the executable JAR (should be the only one now)
        EXECUTABLE_JAR=$(ls build/libs/*.jar 2>/dev/null | head -1)
        if [ ! -f "$EXECUTABLE_JAR" ]; then
          echo "‚ùå No executable JAR found"
          ls -la build/libs/
          exit 1
        fi
        
        echo "üöÄ Starting backend with: $EXECUTABLE_JAR"
        nohup java -jar "$EXECUTABLE_JAR" > backend.log 2>&1 &
        BACKEND_PID=$!
        echo $BACKEND_PID > backend.pid
        echo "Backend PID: $BACKEND_PID"
        
        # Wait for backend to start with more detailed logging
        timeout=120
        while [ $timeout -gt 0 ]; do
          # Check if process is still running
          if ! kill -0 $BACKEND_PID 2>/dev/null; then
            echo "‚ùå Backend process died. Checking logs..."
            tail -n 20 backend.log
            exit 1
          fi
          
          # Check if health endpoint is available
          if curl -f http://localhost:8080/actuator/health >/dev/null 2>&1; then
            echo "‚úÖ Backend started successfully!"
            curl -s http://localhost:8080/actuator/health | jq '.' || echo "Health check response received"
            break
          fi
          
          echo "‚è≥ Waiting for backend to start... ($timeout seconds left)"
          # Show recent logs for debugging
          if [ $((timeout % 20)) -eq 0 ]; then
            echo "üìã Recent backend logs:"
            tail -n 5 backend.log 2>/dev/null || echo "No logs yet"
          fi
          sleep 3
          timeout=$((timeout-3))
        done
        
        if [ $timeout -eq 0 ]; then
          echo "‚ùå Backend failed to start within timeout"
          echo "üìã Full backend logs:"
          cat backend.log
          exit 1
        fi    # Build frontend first (without backend URL for now)
    - name: Install Frontend Dependencies
      working-directory: ./frontend
      run: npm ci



    # Start ngrok for backend first
    # No need to expose backend - Frontend will connect to backend internally

    # Start frontend initially (will be restarted later with backend URL)
    - name: Start Frontend Initially  
      working-directory: ./frontend
      run: |
        echo "üöÄ Starting frontend initially (will restart with backend URL later)"
        nohup npm start > frontend.log 2>&1 &
        echo $! > frontend.pid
        
        # Wait for initial startup
        timeout=30
        while [ $timeout -gt 0 ]; do
          if curl -f http://localhost:3000 >/dev/null 2>&1; then
            echo "‚úÖ Frontend started initially!"
            break
          fi
          echo "‚è≥ Waiting for frontend initial start... ($timeout seconds left)"
          sleep 2
          timeout=$((timeout-2))
        done

    # Setup Nginx reverse proxy
    - name: Setup Nginx Reverse Proxy
      run: |
        # Copy nginx config
        sudo cp nginx.conf /etc/nginx/nginx.conf
        
        # Test nginx config
        sudo nginx -t
        
        # Start nginx
        sudo systemctl start nginx
        sudo systemctl status nginx --no-pager
        
        # Verify nginx is serving
        echo "üîç Testing nginx proxy..."
        curl -f http://localhost/ >/dev/null && echo "‚úÖ Frontend accessible via nginx" || echo "‚ùå Frontend not accessible"
        curl -f http://localhost/actuator/health >/dev/null && echo "‚úÖ Backend accessible via nginx" || echo "‚ùå Backend not accessible"

    # Setup single ngrok tunnel for nginx proxy
    - name: Start Ngrok Tunnel for Nginx
      run: |
        # Start single ngrok tunnel for nginx (port 80)
        nohup ngrok http 80 --log=stdout > ngrok.log 2>&1 &
        NGROK_PID=$!
        echo "Started ngrok tunnel for nginx proxy on port 80 (PID: $NGROK_PID)"
        
        # Wait for tunnel to be ready
        echo "‚è≥ Waiting for ngrok tunnel to be ready..."
        sleep 10
        
        # Check if ngrok process is still running
        if ! kill -0 $NGROK_PID 2>/dev/null; then
          echo "‚ùå Ngrok process died"
          cat ngrok.log
          exit 1
        fi
        
        # Wait for ngrok API to be available
        timeout=30
        while [ $timeout -gt 0 ]; do
          if curl -f http://localhost:4040/api/tunnels >/dev/null 2>&1; then
            echo "‚úÖ Ngrok API is ready"
            break
          fi
          echo "‚è≥ Waiting for ngrok API... ($timeout seconds left)"
          sleep 2
          timeout=$((timeout-2))
        done
        
        # Debug: Show all tunnels
        echo "üîç Debug: Ngrok tunnel:"
        TUNNELS_JSON=$(curl -s http://localhost:4040/api/tunnels)
        echo "$TUNNELS_JSON" | jq '.'
        
        # Extract the public URL (prefer HTTPS)
        DEMO_URL=$(echo "$TUNNELS_JSON" | jq -r '.tunnels[] | select(.proto=="https") | .public_url')
        
        # Fallback to HTTP if HTTPS not available
        if [ "$DEMO_URL" = "null" ] || [ -z "$DEMO_URL" ]; then
          DEMO_URL=$(echo "$TUNNELS_JSON" | jq -r '.tunnels[0].public_url')
        fi
        
        echo "DEMO_URL=$DEMO_URL" >> $GITHUB_ENV
        echo "‚úÖ Demo URL: $DEMO_URL"
        
        if [ "$DEMO_URL" = "null" ] || [ -z "$DEMO_URL" ]; then
          echo "‚ùå Failed to get ngrok URL"
          echo "Available tunnels:"
          echo "$TUNNELS_JSON" | jq '.tunnels[] | {name, public_url, config}'
          exit 1
        fi
        
        # Test the demo URL
        echo "üß™ Testing demo URL..."
        curl -f "$DEMO_URL/" >/dev/null && echo "‚úÖ Frontend accessible via $DEMO_URL" || echo "‚ö†Ô∏è Frontend test failed"
        curl -f "$DEMO_URL/actuator/health" >/dev/null && echo "‚úÖ Backend API accessible via $DEMO_URL/api" || echo "‚ö†Ô∏è Backend API test failed"

    # Rebuild frontend with relative API URLs (nginx will proxy /api to backend)
    - name: Rebuild Frontend for Nginx Proxy
      working-directory: ./frontend
      env:
        NEXT_PUBLIC_BACKEND_URL: ""  # Use relative URLs - nginx will proxy /api to backend
      run: |
        echo "üîÑ Rebuilding frontend for nginx proxy (using relative /api URLs)"
        npm run build

    # Restart frontend with relative URLs
    - name: Restart Frontend for Nginx Proxy
      working-directory: ./frontend
      run: |
        # Kill existing frontend process
        if [ -f frontend.pid ]; then
          kill $(cat frontend.pid) || true
          rm frontend.pid
        fi
        
        # Start frontend (nginx will proxy requests)
        nohup npm start > frontend.log 2>&1 &
        echo $! > frontend.pid
        
        # Wait for frontend to restart
        timeout=30
        while [ $timeout -gt 0 ]; do
          if curl -f http://localhost:3000 >/dev/null 2>&1; then
            echo "‚úÖ Frontend restarted successfully!"
            break
          fi
          echo "‚è≥ Waiting for frontend to restart... ($timeout seconds left)"
          sleep 2
          timeout=$((timeout-2))
        done

    # Create GitHub issue with demo URLs
    - name: Create Demo Issue
      id: create_issue
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        script: |
          const demoInfo = `
          # üöÄ Live Demo Available!
          
          **Demo Message:** ${{ github.event.inputs.demo_message }}
          **Duration:** ${{ github.event.inputs.demo_duration }} minutes
          **Started:** ${new Date().toISOString()}
          
          ## üîó Access URL
          
          ### üåê Demo Application
          **URL:** ${{ env.DEMO_URL }}
          
          **Features:**
          - ‚úÖ **Frontend UI**: `${{ env.DEMO_URL }}/`
          - ‚úÖ **Backend API**: `${{ env.DEMO_URL }}/api/v1`
          - ‚úÖ **Health Check**: `${{ env.DEMO_URL }}/actuator/health`
          
          **Available Functions:**
          - üìã Rules Management Interface
          - üîÑ Version Control System  
          - üìù Change Request Workflow
          - üåç WCO Data Processing
          
          **API Endpoints:**
          - ÔøΩ Rules API: `${{ env.DEMO_URL }}/api/v1/rules`
          - üì¶ Metadata: `${{ env.DEMO_URL }}/api/v1/rules/metadata`
          - üè• Health: `${{ env.DEMO_URL }}/actuator/health`
          
          ## üìä Sample WCO Data
          
          Test with sample JSON data available in the project:
          - Import Goods Declaration
          - Cargo Report Inventory
          
          ## ‚ö° Quick Test
          
          1. Open Frontend URL
          2. Navigate to Rules section
          3. Create/Edit business rules
          4. Test with WCO sample data
          
          ---
          
          > **‚ö†Ô∏è Important:** This demo will automatically stop in ${{ github.event.inputs.demo_duration }} minutes.
          > The URLs are temporary and will become inactive after the demo ends.
          
          **Workflow Run:** [${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          `;
          
          try {
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üöÄ Live Demo #${{ github.run_number }} - ${{ github.event.inputs.demo_message }}`,
              body: demoInfo,
              labels: ['demo', 'temporary']
            });
            
            console.log(`‚úÖ Created demo issue: ${issue.html_url}`);
            core.setOutput('issue_url', issue.html_url);
          } catch (error) {
            console.log(`‚ö†Ô∏è Failed to create issue: ${error.message}`);
            console.log(`üìù Demo info will be shown in workflow logs instead`);
            core.setOutput('issue_url', '');
          }

    # Fallback: Output demo URLs in workflow summary if issue creation failed
    - name: Demo URLs Summary
      run: |
        cat << 'EOF' >> $GITHUB_STEP_SUMMARY
        # üöÄ Live Demo Available!
        
        **Demo Message:** ${{ github.event.inputs.demo_message }}
        **Duration:** ${{ github.event.inputs.demo_duration }} minutes
        **Started:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        ## üîó Access URL
        
        ### üåê Demo Application
        **URL:** ${{ env.DEMO_URL }}
        
        ## üß™ Quick Test
        
        - **Frontend UI:** Open ${{ env.DEMO_URL }} 
        - **Backend API:** Test ${{ env.DEMO_URL }}/actuator/health
        - **Rules API:** Test ${{ env.DEMO_URL }}/api/v1/rules
        - **Single Domain:** All services accessible via one URL
        
        ## ‚ö†Ô∏è Important
        This demo will automatically stop in ${{ github.event.inputs.demo_duration }} minutes.
        The URLs are temporary and will become inactive after the demo ends.
        EOF

    # Keep demo alive for specified duration
    - name: Keep Demo Alive
      run: |
        duration_minutes=${{ github.event.inputs.demo_duration }}
        duration_seconds=$((duration_minutes * 60))
        
        echo "üéØ Demo will run for $duration_minutes minutes ($duration_seconds seconds)"
        echo ""
        echo "üåê Demo URL: ${{ env.DEMO_URL }}"
        echo ""
        echo "‚è∞ Demo started at: $(date)"
        echo "‚è∞ Demo will end at: $(date -d "+$duration_minutes minutes" 2>/dev/null || date -v+${duration_minutes}M 2>/dev/null || echo "$(date) + $duration_minutes minutes")"
        echo ""
        echo "üß™ How to test:"
        echo "  1. Frontend UI: ${{ env.DEMO_URL }}/"
        echo "  2. Backend API: ${{ env.DEMO_URL }}/actuator/health"  
        echo "  3. Rules API: ${{ env.DEMO_URL }}/api/v1/rules"
        echo "  4. Single domain for all services!"
        
        # Keep alive and show logs
        end_time=$(($(date +%s) + duration_seconds))
        while [ $(date +%s) -lt $end_time ]; do
          remaining=$((end_time - $(date +%s)))
          minutes=$((remaining / 60))
          seconds=$((remaining % 60))
          
          echo "‚è≥ Demo running... ${minutes}m ${seconds}s remaining"
          
          # Show recent logs every minute
          if [ $((remaining % 60)) -eq 0 ]; then
            echo "üìã Recent Backend Logs:"
            tail -n 5 ./backend/backend.log || echo "No backend logs"
            echo ""
            echo "üìã Recent Frontend Logs:"
            tail -n 5 ./frontend/frontend.log || echo "No frontend logs"
            echo "---"
          fi
          
          sleep 10
        done
        
        echo "‚è∞ Demo time ended at: $(date)"

    # Cleanup
    - name: Cleanup Demo
      if: always()
      run: |
        echo "üßπ Cleaning up demo..."
        
        # Kill application processes
        if [ -f ./backend/backend.pid ]; then
          kill $(cat ./backend/backend.pid) || true
        fi
        if [ -f ./frontend/frontend.pid ]; then
          kill $(cat ./frontend/frontend.pid) || true
        fi
        
        # Stop nginx
        sudo systemctl stop nginx || true
        
        # Kill ngrok processes
        pkill ngrok || true
        
        echo "‚úÖ Cleanup completed"

    # Debug information
    - name: Debug Information
      if: always()
      run: |
        echo "## üîç Debug Information"
        echo "### Process Status:"
        ps aux | grep -E "(java|node|ngrok)" | grep -v grep || echo "No relevant processes found"
        
        echo ""
        echo "### Port Status:"
        netstat -tlnp 2>/dev/null | grep -E ":8080|:3000|:4040|:4041" || echo "No ports found"
        
        echo ""
        echo "### Log Files:"
        for log in backend.log frontend.log ngrok.log; do
          if [ -f "$log" ]; then
            echo "üìÑ $log (last 10 lines):"
            tail -n 10 "$log"
            echo ""
          fi
        done
        
        echo "### Nginx Status:"
        sudo systemctl status nginx --no-pager || echo "Nginx not running"

    # Final status
    - name: Demo Summary
      if: always()
      run: |
        echo "## üìä Demo Summary"
        echo "**Duration:** ${{ github.event.inputs.demo_duration }} minutes"
        echo "**Demo URL:** ${{ env.DEMO_URL }}"
        echo "**Status:** Demo completed"
        echo ""
        echo "üéØ **Demo Architecture:**"
        echo "   - Nginx Reverse Proxy: Single entry point on port 80"
        echo "   - Frontend (/) ‚Üí localhost:3000 (Next.js)"
        echo "   - Backend (/api, /actuator) ‚Üí localhost:8080 (Spring Boot)"
        echo "   - Single ngrok tunnel ‚Üí nginx ‚Üí internal services"
        echo ""
        echo "Thank you for trying Drools UI Demo! üéâ"