name: Live Demo with Ngrok

on:
  workflow_dispatch:
    inputs:
      demo_duration:
        description: 'Demo duration in minutes'
        required: false
        default: '10'
        type: string
      demo_message:
        description: 'Demo description/message'
        required: false
        default: 'Drools UI Demo'
        type: string

# Grant permissions for the workflow to create issues
permissions:
  issues: write
  contents: read

env:
  NODE_VERSION: '22'
  JAVA_VERSION: '17'

jobs:
  live-demo:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Max 15 minutes to prevent infinite runs
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: rule_engine
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    # Install ngrok
    - name: Install ngrok
      run: |
        curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
        echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
        sudo apt update && sudo apt install ngrok
        ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}

    # Build and start backend
    - name: Build Backend
      working-directory: ./backend
      run: |
        chmod +x ./gradlew
        ./gradlew build -x test
        
        # List generated JAR files for debugging
        echo "üìÅ Generated JAR files:"
        ls -la build/libs/
        
        # Check if JAR is executable
        JAR_FILE=$(ls build/libs/*.jar | head -1)
        if [ -f "$JAR_FILE" ]; then
          echo "‚úÖ JAR file found: $JAR_FILE"
          echo "üìä JAR file size: $(du -h "$JAR_FILE")"
        else
          echo "‚ùå No JAR file found in build/libs/"
          exit 1
        fi

    - name: Start Backend in Background
      working-directory: ./backend
      env:
        SPRING_PROFILES_ACTIVE: docker
        SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/rule_engine
        SPRING_DATASOURCE_USERNAME: postgres
        SPRING_DATASOURCE_PASSWORD: postgres
        SPRING_JPA_HIBERNATE_DDL_AUTO: update
        SERVER_PORT: 8080
      run: |
        nohup java -jar build/libs/*.jar > backend.log 2>&1 &
        BACKEND_PID=$!
        echo $BACKEND_PID > backend.pid
        echo "Backend PID: $BACKEND_PID"
        
        # Wait for backend to start with more detailed logging
        timeout=120
        while [ $timeout -gt 0 ]; do
          # Check if process is still running
          if ! kill -0 $BACKEND_PID 2>/dev/null; then
            echo "‚ùå Backend process died. Checking logs..."
            tail -n 20 backend.log
            exit 1
          fi
          
          # Check if health endpoint is available
          if curl -f http://localhost:8080/actuator/health >/dev/null 2>&1; then
            echo "‚úÖ Backend started successfully!"
            curl -s http://localhost:8080/actuator/health | jq '.' || echo "Health check response received"
            break
          fi
          
          echo "‚è≥ Waiting for backend to start... ($timeout seconds left)"
          # Show recent logs for debugging
          if [ $((timeout % 20)) -eq 0 ]; then
            echo "üìã Recent backend logs:"
            tail -n 5 backend.log 2>/dev/null || echo "No logs yet"
          fi
          sleep 3
          timeout=$((timeout-3))
        done
        
        if [ $timeout -eq 0 ]; then
          echo "‚ùå Backend failed to start within timeout"
          echo "üìã Full backend logs:"
          cat backend.log
          exit 1
        fi    # Build frontend first (without backend URL for now)
    - name: Install Frontend Dependencies
      working-directory: ./frontend
      run: npm ci

    - name: Build Frontend
      working-directory: ./frontend
      env:
        NEXT_PUBLIC_API_URL: http://localhost:8080
      run: npm run build

    # Start ngrok for backend first
    - name: Start Ngrok for Backend
      run: |
        nohup ngrok http 8080 --log=stdout > ngrok-backend.log 2>&1 &
        sleep 10
        
        # Get backend URL with retry
        for i in {1..5}; do
          BACKEND_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url' 2>/dev/null)
          if [ "$BACKEND_URL" != "null" ] && [ -n "$BACKEND_URL" ]; then
            echo "BACKEND_URL=$BACKEND_URL" >> $GITHUB_ENV
            echo "Backend URL: $BACKEND_URL"
            break
          fi
          echo "Waiting for ngrok backend tunnel... (attempt $i/5)"
          sleep 3
        done

    # Start frontend with the backend URL available
    - name: Start Frontend in Background
      working-directory: ./frontend
      env:
        # Frontend will proxy API calls to backend
        NEXT_PUBLIC_API_URL: ${{ env.BACKEND_URL }}
      run: |
        nohup npm start > frontend.log 2>&1 &
        echo $! > frontend.pid
        
        # Wait for frontend to start
        timeout=60
        while [ $timeout -gt 0 ]; do
          if curl -f http://localhost:3000 >/dev/null 2>&1; then
            echo "Frontend started successfully!"
            break
          fi
          echo "Waiting for frontend to start... ($timeout seconds left)"
          sleep 2
          timeout=$((timeout-2))
        done

    # Setup frontend ngrok tunnel
    - name: Start Frontend Ngrok Tunnel
      run: |
        echo "üåê Starting ngrok tunnel for frontend (port 3000)..."
        
        # Check if frontend is actually running
        echo "Checking if frontend is accessible..."
        for i in {1..5}; do
          if curl -f http://localhost:3000 2>/dev/null; then
            echo "‚úÖ Frontend is responding on port 3000"
            break
          fi
          echo "Attempt $i/5: Frontend not responding yet..."
          sleep 2
        done
        
        # Start ngrok tunnel for frontend with better error handling
        echo "Starting ngrok tunnel for frontend..."
        nohup ngrok http 3000 --log=stdout > ngrok-frontend.log 2>&1 &
        NGROK_FRONTEND_PID=$!
        echo "NGROK_FRONTEND_PID=$NGROK_FRONTEND_PID" >> $GITHUB_ENV
        echo "Frontend ngrok PID: $NGROK_FRONTEND_PID"
        
        # Wait for frontend ngrok to be ready with detailed logging
        echo "Waiting for frontend ngrok tunnel..."
        for i in {1..30}; do
          sleep 2
          
          # Check ngrok API
          NGROK_RESPONSE=$(curl -s http://localhost:4040/api/tunnels 2>/dev/null || echo "{}")
          echo "Ngrok API response: $NGROK_RESPONSE"
          
          # Extract frontend tunnel
          FRONTEND_URL=$(echo "$NGROK_RESPONSE" | jq -r '.tunnels[] | select(.config.addr | contains("3000")) | .public_url' 2>/dev/null | head -1)
          
          if [ "$FRONTEND_URL" != "null" ] && [ -n "$FRONTEND_URL" ] && [ "$FRONTEND_URL" != "" ]; then
            echo "FRONTEND_URL=$FRONTEND_URL" >> $GITHUB_ENV
            echo "‚úÖ Frontend tunnel ready: $FRONTEND_URL"
            
            # Test the tunnel
            echo "Testing frontend tunnel..."
            if curl -f "$FRONTEND_URL" 2>/dev/null; then
              echo "‚úÖ Frontend tunnel is working!"
              break
            else
              echo "‚ö†Ô∏è Frontend tunnel created but not responding"
            fi
          fi
          
          echo "Attempt $i/30: Frontend tunnel not ready yet..."
          if [ $i -eq 15 ]; then
            echo "üìã Frontend ngrok log (last 10 lines):"
            tail -n 10 ngrok-frontend.log 2>/dev/null || echo "No log available"
          fi
        done
        
        if [ -z "$FRONTEND_URL" ] || [ "$FRONTEND_URL" = "null" ]; then
          echo "‚ùå Frontend ngrok tunnel failed to start"
          echo "üìã Final frontend ngrok log:"
          cat ngrok-frontend.log 2>/dev/null || echo "No log available"
          exit 1
        fi

    # Create GitHub issue with demo URLs
    - name: Create Demo Issue
      id: create_issue
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        script: |
          const demoInfo = `
          # üöÄ Live Demo Available!
          
          **Demo Message:** ${{ github.event.inputs.demo_message }}
          **Duration:** ${{ github.event.inputs.demo_duration }} minutes
          **Started:** ${new Date().toISOString()}
          
          ## üîó Access URLs
          
          ### Frontend (Next.js UI)
          **URL:** ${{ env.FRONTEND_URL }}
          
          **Features:**
          - ‚úÖ Rules Management Interface
          - ‚úÖ Version Control System
          - ‚úÖ Change Request Workflow
          - ‚úÖ WCO Data Processing
          
          ### Backend (Spring Boot API)
          **URL:** ${{ env.BACKEND_URL }}
          
          **API Endpoints:**
          - \`GET /api/rules\` - List all rules
          - \`GET /api/rules/{id}\` - Get rule details
          - \`POST /api/rules\` - Create new rule
          - \`GET /actuator/health\` - Health check
          
          ## üìä Sample WCO Data
          
          Test with sample JSON data available in the project:
          - Import Goods Declaration
          - Cargo Report Inventory
          
          ## ‚ö° Quick Test
          
          1. Open Frontend URL
          2. Navigate to Rules section
          3. Create/Edit business rules
          4. Test with WCO sample data
          
          ---
          
          > **‚ö†Ô∏è Important:** This demo will automatically stop in ${{ github.event.inputs.demo_duration }} minutes.
          > The URLs are temporary and will become inactive after the demo ends.
          
          **Workflow Run:** [${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          `;
          
          try {
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üöÄ Live Demo #${{ github.run_number }} - ${{ github.event.inputs.demo_message }}`,
              body: demoInfo,
              labels: ['demo', 'temporary']
            });
            
            console.log(`‚úÖ Created demo issue: ${issue.html_url}`);
            core.setOutput('issue_url', issue.html_url);
          } catch (error) {
            console.log(`‚ö†Ô∏è Failed to create issue: ${error.message}`);
            console.log(`üìù Demo info will be shown in workflow logs instead`);
            core.setOutput('issue_url', '');
          }

    # Fallback: Output demo URLs in workflow summary if issue creation failed
    - name: Demo URLs Summary
      run: |
        cat << 'EOF' >> $GITHUB_STEP_SUMMARY
        # üöÄ Live Demo Available!
        
        **Demo Message:** ${{ github.event.inputs.demo_message }}
        **Duration:** ${{ github.event.inputs.demo_duration }} minutes
        **Started:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        ## üîó Access URLs
        
        ### Frontend (Next.js UI)
        **URL:** ${{ env.FRONTEND_URL }}
        
        ### Backend (Spring Boot API)  
        **URL:** ${{ env.BACKEND_URL }}
        
        ## üß™ Quick Test Commands
        
        ```bash
        # Health check
        curl ${{ env.BACKEND_URL }}/actuator/health
        
        # List rules
        curl ${{ env.BACKEND_URL }}/api/rules
        ```
        
        ## ‚ö†Ô∏è Important
        This demo will automatically stop in ${{ github.event.inputs.demo_duration }} minutes.
        The URLs are temporary and will become inactive after the demo ends.
        EOF

    # Keep demo alive for specified duration
    - name: Keep Demo Alive
      run: |
        duration_minutes=${{ github.event.inputs.demo_duration }}
        duration_seconds=$((duration_minutes * 60))
        
        echo "üéØ Demo will run for $duration_minutes minutes ($duration_seconds seconds)"
        echo ""
        echo "üåê Frontend: ${{ env.FRONTEND_URL }}"
        echo "üîß Backend:  ${{ env.BACKEND_URL }}"
        echo ""
        echo "‚è∞ Demo started at: $(date)"
        echo "‚è∞ Demo will end at: $(date -d "+$duration_minutes minutes" 2>/dev/null || date -v+${duration_minutes}M 2>/dev/null || echo "$(date) + $duration_minutes minutes")"
        echo ""
        echo "üß™ Test Commands:"
        echo "  curl ${{ env.BACKEND_URL }}/actuator/health"
        echo "  curl ${{ env.BACKEND_URL }}/api/rules"
        
        # Keep alive and show logs
        end_time=$(($(date +%s) + duration_seconds))
        while [ $(date +%s) -lt $end_time ]; do
          remaining=$((end_time - $(date +%s)))
          minutes=$((remaining / 60))
          seconds=$((remaining % 60))
          
          echo "‚è≥ Demo running... ${minutes}m ${seconds}s remaining"
          
          # Show recent logs every minute
          if [ $((remaining % 60)) -eq 0 ]; then
            echo "üìã Recent Backend Logs:"
            tail -n 5 ./backend/backend.log || echo "No backend logs"
            echo ""
            echo "üìã Recent Frontend Logs:"
            tail -n 5 ./frontend/frontend.log || echo "No frontend logs"
            echo "---"
          fi
          
          sleep 10
        done
        
        echo "‚è∞ Demo time ended at: $(date)"

    # Cleanup
    - name: Cleanup Demo
      if: always()
      run: |
        echo "üßπ Cleaning up demo..."
        
        # Kill processes
        if [ -f ./backend/backend.pid ]; then
          kill $(cat ./backend/backend.pid) || true
        fi
        if [ -f ./frontend/frontend.pid ]; then
          kill $(cat ./frontend/frontend.pid) || true
        fi
        
        # Kill ngrok processes
        pkill ngrok || true
        
        echo "‚úÖ Cleanup completed"

    # Debug information
    - name: Debug Information
      if: always()
      run: |
        echo "## üîç Debug Information"
        echo "### Process Status:"
        ps aux | grep -E "(java|node|ngrok)" | grep -v grep || echo "No relevant processes found"
        
        echo ""
        echo "### Port Status:"
        netstat -tlnp 2>/dev/null | grep -E ":8080|:3000|:4040|:4041" || echo "No ports found"
        
        echo ""
        echo "### Log Files:"
        for log in backend.log frontend.log ngrok-backend.log ngrok-frontend.log; do
          if [ -f "$log" ]; then
            echo "üìÑ $log (last 10 lines):"
            tail -n 10 "$log"
            echo ""
          fi
        done

    # Final status
    - name: Demo Summary
      if: always()
      run: |
        echo "## üìä Demo Summary"
        echo "**Duration:** ${{ github.event.inputs.demo_duration }} minutes"
        echo "**Frontend URL:** ${{ env.FRONTEND_URL }}"
        echo "**Backend URL:** ${{ env.BACKEND_URL }}"
        echo "**Status:** Demo completed"
        echo ""
        echo "üéØ **Why both Frontend AND Backend are exposed:**"
        echo "   - Frontend: User interface for rules management"
        echo "   - Backend: REST API for data processing and WCO validation"
        echo "   - Both needed for complete demo functionality"
        echo ""
        echo "Thank you for trying Drools UI Demo! üéâ"